{
  "category": "dangerous-calls",
  "patterns": [
    {
      "id": "pycall-001",
      "name": "subprocess-shell-true",
      "description": "Uses subprocess with shell=True, enabling shell injection",
      "severity": "CRITICAL",
      "match": {
        "type": "regex",
        "value": "subprocess\\.(run|call|Popen|check_output|check_call)\\s*\\([^)]*shell\\s*=\\s*True",
        "flags": "g"
      },
      "layer": "code",
      "remediation": {
        "title": "Remove shell=True from subprocess calls",
        "suggestions": [
          "Use explicit argument lists: subprocess.run(['cmd', 'arg1', 'arg2'])",
          "Never set shell=True, especially with user input",
          "Use shlex.quote() if you must construct shell commands",
          "Consider using pathlib or os.path for file operations instead",
          "Validate and sanitize all arguments before passing to subprocess"
        ]
      }
    },
    {
      "id": "pycall-002",
      "name": "os-system-call",
      "description": "Uses os.system() for direct shell command execution",
      "severity": "CRITICAL",
      "match": {
        "type": "regex",
        "value": "os\\.system\\s*\\(",
        "flags": "g"
      },
      "layer": "code",
      "remediation": {
        "title": "Replace os.system() with subprocess",
        "suggestions": [
          "Use subprocess.run() with explicit arguments instead",
          "Never use os.system() with user-controlled input",
          "Consider using built-in Python APIs for file/path operations",
          "If shell commands are needed, use subprocess without shell=True"
        ]
      }
    },
    {
      "id": "pycall-003",
      "name": "os-popen-call",
      "description": "Uses os.popen() for shell command execution",
      "severity": "CRITICAL",
      "match": {
        "type": "regex",
        "value": "os\\.popen[234]?\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-004",
      "name": "os-exec-family",
      "description": "Uses os.exec* family for program execution",
      "severity": "HIGH",
      "match": {
        "type": "regex",
        "value": "os\\.(execl|execle|execlp|execlpe|execv|execve|execvp|execvpe)\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-005",
      "name": "os-spawn-family",
      "description": "Uses os.spawn* family for process spawning",
      "severity": "HIGH",
      "match": {
        "type": "regex",
        "value": "os\\.(spawnl|spawnle|spawnlp|spawnlpe|spawnv|spawnve|spawnvp|spawnvpe)\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-006",
      "name": "pickle-loads-call",
      "description": "Uses pickle.loads() which can execute arbitrary code",
      "severity": "CRITICAL",
      "match": {
        "type": "regex",
        "value": "pickle\\.(loads?|Unpickler)\\s*\\(",
        "flags": "g"
      },
      "layer": "code",
      "remediation": {
        "title": "Avoid unpickling untrusted data",
        "suggestions": [
          "Use json.loads() for deserializing JSON data instead",
          "Never unpickle data from untrusted or user-controlled sources",
          "If pickle is required, verify data integrity with HMAC signatures",
          "Consider using safer formats like JSON, msgpack, or protobuf",
          "Implement a restricted unpickler with custom find_class() method"
        ]
      }
    },
    {
      "id": "pycall-007",
      "name": "marshal-loads-call",
      "description": "Uses marshal.loads() for deserialization",
      "severity": "HIGH",
      "match": {
        "type": "regex",
        "value": "marshal\\.loads?\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-008",
      "name": "yaml-unsafe-load",
      "description": "Uses yaml.load() without safe loader, enabling arbitrary code execution",
      "severity": "CRITICAL",
      "match": {
        "type": "regex",
        "value": "yaml\\.load\\s*\\([^,)]*\\)",
        "flags": "g"
      },
      "layer": "code",
      "remediation": {
        "title": "Use yaml.safe_load() instead",
        "suggestions": [
          "Replace yaml.load() with yaml.safe_load()",
          "If you need custom tags, use yaml.load(data, Loader=yaml.SafeLoader)",
          "Never use yaml.load() with untrusted input",
          "Consider validating YAML structure after loading"
        ]
      }
    },
    {
      "id": "pycall-009",
      "name": "code-object-exec",
      "description": "Executes code objects from compile()",
      "severity": "HIGH",
      "match": {
        "type": "regex",
        "value": "exec\\s*\\(\\s*compile\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-010",
      "name": "file-write-operations",
      "description": "Opens files in write mode which could overwrite data",
      "severity": "MEDIUM",
      "match": {
        "type": "regex",
        "value": "open\\s*\\([^)]*['\"]w",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-011",
      "name": "os-remove-operations",
      "description": "Deletes files or directories",
      "severity": "MEDIUM",
      "match": {
        "type": "regex",
        "value": "os\\.(remove|unlink|rmdir|removedirs)\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-012",
      "name": "shutil-rmtree",
      "description": "Recursively deletes directory trees",
      "severity": "HIGH",
      "match": {
        "type": "regex",
        "value": "shutil\\.rmtree\\s*\\(",
        "flags": "g"
      },
      "layer": "code"
    },
    {
      "id": "pycall-013",
      "name": "tempfile-mktemp",
      "description": "Uses deprecated mktemp() which has security issues",
      "severity": "MEDIUM",
      "match": {
        "type": "regex",
        "value": "tempfile\\.mktemp\\s*\\(",
        "flags": "g"
      },
      "layer": "code",
      "remediation": {
        "title": "Replace mktemp() with safer alternatives",
        "suggestions": [
          "Use tempfile.mkstemp() which creates files securely",
          "Use tempfile.TemporaryFile() for automatic cleanup",
          "Use tempfile.NamedTemporaryFile() if you need a file name",
          "Never use mktemp() as it's vulnerable to race conditions"
        ]
      }
    },
    {
      "id": "pycall-014",
      "name": "assert-statement",
      "description": "Uses assert statements which are removed in optimized bytecode",
      "severity": "LOW",
      "match": {
        "type": "regex",
        "value": "\\bassert\\s+",
        "flags": "g"
      },
      "layer": "code"
    }
  ]
}
